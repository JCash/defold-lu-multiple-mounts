
function init(self)
	msg.post("@render:", "use_fixed_fit_projection", { near = -1, far = 1 })

	self.resources_pending = 0 -- <1>
	--msg.post("#", "attempt_load_resources")

	print("Live Update Cache is located here: " .. sys.get_save_file("", ""))

	self.http_url = sys.get_config_string("test.http_url", nil)
	self.resource_dir = sys.get_config_string("test.resource_dir", nil)
	print("Using local dir: ", self.resource_dir)
	print("Using http url: ", self.http_url)
	if self.http_url then
	end
end

function on_input(self, action_id, action)
	if action_id == hash("touch") and action.pressed then
		print("Touch!")
	end
end

-- This function is called whenever we have tried to store a downloaded resource
-- necessary for our collection proxy to load.
local function resource_store_response(self, hexdigest, status)
	if status == true then
		-- Successfully loaded resource
		print("Resource data stored: " .. hexdigest)

		-- One less resource to go...
		self.resources_pending = self.resources_pending - 1

		-- That was all of them, time to load the proxied collection.
		if self.resources_pending == 0 then
			msg.post("#proxy", "load") -- <8>
		end
	else
		-- ERROR! Failed to store the data!
		print("Failed to store resource data: " .. hexdigest)
	end
end

local function get_status_string(status)
	local manifest_errors = {
		[liveupdate.LIVEUPDATE_BUNDLED_RESOURCE_MISMATCH] = "LIVEUPDATE_BUNDLED_RESOURCE_MISMATCH",
		[liveupdate.LIVEUPDATE_ENGINE_VERSION_MISMATCH] = "LIVEUPDATE_ENGINE_VERSION_MISMATCH",
		[liveupdate.LIVEUPDATE_FORMAT_ERROR] = "LIVEUPDATE_FORMAT_ERROR",
		[liveupdate.LIVEUPDATE_INVALID_RESOURCE] = "LIVEUPDATE_INVALID_RESOURCE",
		[liveupdate.LIVEUPDATE_SCHEME_MISMATCH] = "LIVEUPDATE_SCHEME_MISMATCH",
		[liveupdate.LIVEUPDATE_SIGNATURE_MISMATCH] = "LIVEUPDATE_SIGNATURE_MISMATCH",
		[liveupdate.LIVEUPDATE_VERSION_MISMATCH] = "LIVEUPDATE_VERSION_MISMATCH",
	}
	return manifest_errors[status]
end

local function store_manifest_cb(self, status)
	if status == resource.LIVEUPDATE_OK then
		print("Successfully stored manifest!")
	else
		print("Failed to store manifest, status: ", get_status_string(status))
	end
end

local function mount_zip(self, name, priority, path, callback)
	print("Mounting zip from ", path)
	liveupdate.add_mount(name, "zip:" .. path, priority, function(_uri, _path, _status)
		callback(_uri, _path, _status)
	end)
end

function on_message(self, message_id, message, sender)

	print("MESSAGE", message_id)
	if message_id == hash('load_level') then
		local level = message.name
		local proxy = '#' .. level

		local missing_resources = collectionproxy.missing_resources(proxy)
		if #missing_resources > 0 then
			pprint("missing_resources")
			for _,x in ipairs(missing_resources) do
				print("  ", x)
			end
		else
			msg.post(proxy, "load")
		end

	elseif message_id == hash("attempt_load_resources") then
		local missing_resources = collectionproxy.missing_resources("#proxy") -- <2>

		-- initiate a download request for each of the missing resources that has not yet been tried.
		for _,resource_hash in ipairs(missing_resources) do
			msg.post("#", "attempt_download", { resource_hash = resource_hash})
		end

		self.resources_pending = #missing_resources -- <3>

		-- if we're running from editor all resources are there from the start.
		if self.resources_pending == 0 then
			msg.post("#proxy", "load")
		end
	elseif message_id == hash("mount_zip") then
		local zip_filename = message.name .. ".zip"
		local download_path = sys.get_save_file("lu_example", zip_filename)
		-- leaving as an excersize for the user
		if self.http_url then
			http.request(self.http_url .. "/" .. zip_filename, "GET", function(self, id, response)
				if response.status == 200 or response.status == 304 then
					mount_zip(self, message.name, message.priority, download_path, function(uri, path, status)
						pprint(uri, path, status)
						msg.post(sender, "update_state")
					end)

				else
					-- ERROR! Failed to download resource!
					print("Failed to download resource: " .. message.resource_hash .. " from " .. self.http_url)
				end
			end, nil, nil, {path=download_path})
		else
			mount_zip(self, message.name, message.priority, self.resource_dir .. "/" .. zip_filename, function(uri, path, status)
				pprint(uri, path, status)
				msg.post(sender, "update_state")
			end)
		end

	elseif message_id == hash("unmount_zip") then
		liveupdate.remove_mount(message.name)
		msg.post(sender, "update_state")

	elseif message_id == hash("proxy_loaded") then
		msg.post(sender, "init")
		msg.post(sender, "enable")
	end
end
